package net.mooctest;

import static org.junit.Assert.assertEquals;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import org.junit.Test;

public class ACOTest {

  @Test(timeout=400)
  public void test(){
      ArrayList<String[]> arrayList0 = new ArrayList<String[]>();
      ACO aCO0 = new ACO(arrayList0, 0, 0, 0.0, 0, 0);
      
      ArrayList<String[]> arrayList1 = new ArrayList<String[]>();
      arrayList1.add(new String[] {"#"});
      arrayList1.add(new String[] {"1"});
      arrayList1.add(new String[] {"2"});
      arrayList1.add(new String[] {"3"});
      arrayList1.add(new String[] {"#"});
      arrayList1.add(new String[] {"1","2","5"});
      arrayList1.add(new String[] {"1","3","4"});
      arrayList1.add(new String[] {"2","3","7"});
      ACO aCO1 = new ACO(arrayList1, 50, 1, 5, 0.5, 200);
      origACO oACO1 = new origACO(arrayList1, 50, 1, 5, 0.5, 200);
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);
        System.setOut(ps);

        // 执行蚁群算法
        aCO1.antStartSearching(100);

        // 恢复原始的System.out
        System.setOut(System.out);

        // 获取捕获的输出
        String actualOutput = baos.toString();
        aCO1.antStartSearching(100);
      //String expectedOutput = "经过100次循环遍历，最终得出的最佳路径：\r\nentrance-->1-->2-->3-->1"
      //assert actualOutput.equals(expectedOutput) : "实际输出与预期输出不符";
      //double[][] pheromoneMatrix = {
        //{-1,-1,-1,0},
        //{-1,-1,-1,0},
        //{-1,-1,-1,0},
        //{0,0,0,0}
      //};
      //ArrayList<String> nonVisitedCitys = new ArrayList<String>();
      //nonVisitedCitys.add("1");
      //nonVisitedCitys.add("2");
      //nonVisitedCitys.add("3");
      //Ant ant0 = new Ant(pheromoneMatrix, nonVisitedCitys);
      //System.out.println(aCO1.selectAntNextCity(ant0, 1).toString());
      // assertEquals(aCO1.selectAntNextCity(ant0, 0));
      String result = oACO1.antStartSearching(100);
      assert actualOutput.equals(result);
      ArrayList<String[]> arrayList2 = new ArrayList<String[]>();
      arrayList2.add(new String[] {"#"});
      arrayList2.add(new String[] {"#"});
      ACO aCO2 = new ACO(arrayList2, 0, 0, 0.0, 0, 0);
  }
}

class origACO {
	// 输入数据类型
	public static final int INPUT_CITY_NAME = 1;
	public static final int INPUT_CITY_DIS = 2;

	// 城市间距离邻接矩阵
	public static double[][] disMatrix;
	// 当前时间
	public static int currentTime;

	// 测试数据地址
	private String filePath;
	// 蚂蚁数量
	private int antNum;
	// 控制参数
	private double alpha;
	private double beita;
	private double p;
	private double Q;
	// 随机数产生器
	private Random random;
	// 城市名称集合,这里为了方便，将城市用数字表示
	private ArrayList<String> totalCitys;
	// 所有的蚂蚁集合
	private ArrayList<Ant> totalAnts;
	// 城市间的信息素浓度矩阵，随着时间的增多而减少
	private double[][] pheromoneMatrix;
	// 目标的最短路径,顺序为从集合的前部往后挪动
	private ArrayList<String> bestPath;
	// 信息素矩阵存储图,key采用的格式(i,j,t)->value
	private Map<String, Double> pheromoneTimeMap;

	public origACO(ArrayList<String[]> dataArray, int antNum, double alpha, double beita,
			double p, double Q) {
		this.antNum = antNum;
		this.alpha = alpha;
		this.beita = beita;
		this.p = p;
		this.Q = Q;
		this.currentTime = 0;

		readDataFile(dataArray);
	}

	/**
	 * 读取数据
	 */
	private void readDataFile(ArrayList<String[]> dataArray) {

		int flag = -1;
		int src = 0;
		int des = 0;
		int size = 0;
		// 进行城市名称种数的统计
		this.totalCitys = new ArrayList<String>();
		for (String[] array : dataArray) {
			if (array[0].equals("#") && totalCitys.size() == 0) {
				flag = INPUT_CITY_NAME;

				continue;
			} else if (array[0].equals("#") && totalCitys.size() > 0) {
				size = totalCitys.size();
				// 初始化距离矩阵
				this.disMatrix = new double[size + 1][size + 1];
				this.pheromoneMatrix = new double[size + 1][size + 1];

				// 初始值-1代表此对应位置无值
				for (int i = 0; i < size; i++) {
					for (int j = 0; j < size; j++) {
						this.disMatrix[i][j] = -1;
						this.pheromoneMatrix[i][j] = -1;
					}
				}

				flag = INPUT_CITY_DIS;
				continue;
			}

			if (flag == INPUT_CITY_NAME) {
				this.totalCitys.add(array[0]);
			} else {
				src = Integer.parseInt(array[0]);
				des = Integer.parseInt(array[1]);

				this.disMatrix[src][des] = Double.parseDouble(array[2]);
				this.disMatrix[des][src] = Double.parseDouble(array[2]);
			}
		}
	}

	/**
	 * 计算从蚂蚁城市i到j的概率
	 * 
	 * @param cityI
	 *            城市I
	 * @param cityJ
	 *            城市J
	 * @param currentTime
	 *            当前时间
	 * @return
	 */
	private double calIToJProbably(String cityI, String cityJ, int currentTime) {
		double pro = 0;
		double n = 0;
		double pheromone;
		int i;
		int j;

		i = Integer.parseInt(cityI);
		j = Integer.parseInt(cityJ);

		pheromone = getPheromone(currentTime, cityI, cityJ);
		n = 1.0 / disMatrix[i][j];

		if (pheromone == 0) {
			pheromone = 1;
		}

		pro = Math.pow(n, alpha) * Math.pow(pheromone, beita);

		return pro;
	}

	/**
	 * 计算综合概率蚂蚁从I城市走到J城市的概率
	 * 
	 * @return
	 */
	public String selectAntNextCity(Ant ant, int currentTime) {
		double randomNum;
		double tempPro;
		// 总概率指数
		double proTotal;
		String nextCity = null;
		ArrayList<String> allowedCitys;
		// 各城市概率集
		double[] proArray;

		// 如果是刚刚开始的时候，没有路过任何城市，则随机返回一个城市
		if (ant.currentPath.size() == 0) {
			nextCity = String.valueOf(random.nextInt(totalCitys.size()) + 1);

			return nextCity;
		} else if (ant.nonVisitedCitys.isEmpty()) {
			// 如果全部遍历完毕，则再次回到起点
			nextCity = ant.currentPath.get(0);

			return nextCity;
		}

		proTotal = 0;
		allowedCitys = ant.nonVisitedCitys;
		proArray = new double[allowedCitys.size()];

		for (int i = 0; i < allowedCitys.size(); i++) {
			nextCity = allowedCitys.get(i);
			proArray[i] = calIToJProbably(ant.currentPos, nextCity, currentTime);
			proTotal += proArray[i];
		}

		for (int i = 0; i < allowedCitys.size(); i++) {
			// 归一化处理
			proArray[i] /= proTotal;
		}

		// 用随机数选择下一个城市
		randomNum = random.nextInt(100) + 1;
		randomNum = randomNum / 100;
		// 因为1.0是无法判断到的，,总和会无限接近1.0取为0.99做判断
		if (randomNum == 1) {
			randomNum = randomNum - 0.01;
		}

		tempPro = 0;
		// 确定区间
		for (int j = 0; j < allowedCitys.size(); j++) {
			if (randomNum > tempPro && randomNum <= tempPro + proArray[j]) {
				// 采用拷贝的方式避免引用重复
				nextCity = allowedCitys.get(j);
				break;
			} else {
				tempPro += proArray[j];
			}
		}

		return nextCity;
	}

	/**
	 * 获取给定时间点上从城市i到城市j的信息素浓度
	 * 
	 * @param t
	 * @param cityI
	 * @param cityJ
	 * @return
	 */
	private double getPheromone(int t, String cityI, String cityJ) {
		double pheromone = 0;
		String key;

		// 上一周期需将时间倒回一周期
		key = MessageFormat.format("{0},{1},{2}", cityI, cityJ, t);

		if (pheromoneTimeMap.containsKey(key)) {
			pheromone = pheromoneTimeMap.get(key);
		}

		return pheromone;
	}

	/**
	 * 每轮结束，刷新信息素浓度矩阵
	 * 
	 * @param t
	 */
	private void refreshPheromone(int t) {
		double pheromone = 0;
		// 上一轮周期结束后的信息素浓度，丛信息素浓度图中查找
		double lastTimeP = 0;
		// 本轮信息素浓度增加量
		double addPheromone;
		String key;

		for (String i : totalCitys) {
			for (String j : totalCitys) {
				if (!i.equals(j)) {
					// 上一周期需将时间倒回一周期
					key = MessageFormat.format("{0},{1},{2}", i, j, t - 1);

					if (pheromoneTimeMap.containsKey(key)) {
						lastTimeP = pheromoneTimeMap.get(key);
					} else {
						lastTimeP = 0;
					}

					addPheromone = 0;
					for (Ant ant : totalAnts) {
						if(ant.pathContained(i, j)){
							// 每只蚂蚁传播的信息素为控制因子除以距离总成本
							addPheromone += Q / ant.calSumDistance();
						}
					}

					// 将上次的结果值加上递增的量，并存入图中
					pheromone = p * lastTimeP + addPheromone;
					key = MessageFormat.format("{0},{1},{2}", i, j, t);
					pheromoneTimeMap.put(key, pheromone);
				}
			}
		}

	}

	/**
	 * 蚁群算法迭代次数
	 * @param loopCount
	 * 具体遍历次数
	 * @return 
	 */
	public String antStartSearching(int loopCount) {
		// 蚁群寻找的总次数
		int count = 0;
		// 选中的下一个城市
		String selectedCity = "";

		pheromoneTimeMap = new HashMap<String, Double>();
		totalAnts = new ArrayList<Ant>();
		random = new Random();

		while (count < loopCount) {
			initAnts();

			while (true) {
				for (Ant ant : totalAnts) {
					selectedCity = selectAntNextCity(ant, currentTime);
					ant.goToNextCity(selectedCity);
				}

				// 如果已经遍历完所有城市，则跳出此轮循环
				if (totalAnts.get(0).isBack()) {
					break;
				}
			}

			// 周期时间叠加
			currentTime++;
			refreshPheromone(currentTime);
			count++;
		}

		// 根据距离成本，选出所花距离最短的一个路径
		Collections.sort(totalAnts);
		bestPath = totalAnts.get(0).currentPath;
    String result = "";
		result += MessageFormat.format("经过{0}次循环遍历，最终得出的最佳路径：", count);
	  result += "\r\nentrance";
		for (String cityName : bestPath) {
			result += (MessageFormat.format("-->{0}", cityName));
		}
    return result;
	}

	/**
	 * 初始化蚁群操作
	 */
	private void initAnts() {
		Ant tempAnt;
		ArrayList<String> nonVisitedCitys;
		totalAnts.clear();

		// 初始化蚁群
		for (int i = 0; i < antNum; i++) {
			nonVisitedCitys = (ArrayList<String>) totalCitys.clone();
			tempAnt = new Ant(pheromoneMatrix, nonVisitedCitys);

			totalAnts.add(tempAnt);
		}
	}
}